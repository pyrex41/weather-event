{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Rust + Axum + Elm with Vite project structure",
        "description": "Initialize Cargo workspace with Rust backend using Axum web framework, and Elm frontend with Vite build tooling via elm-vite-plugin for hot-reload development.",
        "details": "Create Cargo workspace: `cargo init --lib core && cargo init --bin server`. In server directory, add dependencies to Cargo.toml: axum (0.7), tokio (full features), sqlx (sqlite, runtime-tokio-rustls), reqwest (json), serde (derive), serde_json, tower-http (for CORS and static files), tokio-cron-scheduler, axum-typed-websockets, tracing, tracing-subscriber, dotenv. For frontend: `npm create vite@latest elm -- --template vanilla`, then `npm install -D vite vite-plugin-elm`. Create vite.config.js: import { defineConfig } from 'vite'; import { plugin as elm } from 'vite-plugin-elm'; export default defineConfig({ plugins: [elm()] }). Initialize Elm: `cd elm && elm init`. Create static/ directory for Vite build output. Configure Axum to serve static files from dist/.",
        "testStrategy": "Verify Cargo workspace builds with `cargo build`. Start Vite dev server with `npm run dev` and check Elm compiles with hot-reload. Run `cargo run` to start Axum server, verify it serves static files on http://localhost:3000.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Cargo workspace and add Rust dependencies",
            "description": "Set up the Cargo workspace by creating the core library and server binary, then add all necessary dependencies for the Axum backend.",
            "dependencies": [],
            "details": "Execute `cargo init --lib core && cargo init --bin server` to create the workspace structure. In the server directory, update Cargo.toml to include dependencies: axum (0.7), tokio (full features), sqlx (sqlite, runtime-tokio-rustls), reqwest (json), serde (derive), serde_json, tower-http (for CORS and static files), tokio-cron-scheduler, axum-typed-websockets, tracing, tracing-subscriber, dotenv. Ensure the workspace is properly configured in the root Cargo.toml.",
            "status": "pending",
            "testStrategy": "Run `cargo build` to verify the workspace compiles without errors and all dependencies are resolved."
          },
          {
            "id": 2,
            "title": "Set up Elm frontend with Vite and plugins",
            "description": "Initialize the Elm project using Vite as the build tool, install necessary plugins for hot-reload development.",
            "dependencies": [],
            "details": "Run `npm create vite@latest elm -- --template vanilla` to create the Vite project with Elm template. Then install development dependencies with `npm install -D vite vite-plugin-elm`. Create vite.config.js with the following content: import { defineConfig } from 'vite'; import { plugin as elm } from 'vite-plugin-elm'; export default defineConfig({ plugins: [elm()] }). Navigate to the elm directory and run `elm init` to initialize the Elm project.",
            "status": "pending",
            "testStrategy": "Start the Vite dev server with `npm run dev` and check that Elm compiles successfully with hot-reload functionality enabled."
          },
          {
            "id": 3,
            "title": "Configure build process and verify integration",
            "description": "Set up the static directory for Vite build output and configure Axum to serve static files, then verify the entire setup integrates correctly.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a static/ directory to hold the Vite build output. Configure Axum in the server code to serve static files from the dist/ directory (which Vite outputs). Ensure the Axum server is set up to handle the integration, including any necessary routing for static assets. This involves modifying the server code to include static file serving middleware.",
            "status": "pending",
            "testStrategy": "Run `cargo run` to start the Axum server and verify it serves static files on http://localhost:3000. Additionally, ensure the Vite build process outputs to the correct directory and integrates with the Rust backend without conflicts."
          }
        ]
      },
      {
        "id": 2,
        "title": "Design and implement SQLite database schema with sqlx migrations",
        "description": "Create normalized database schema for students, bookings, weather logs, reschedule events, and configurable weather minimums using SQLite with sqlx for compile-time type-safe queries.",
        "details": "In core/ crate, define Rust structs: Student { id: String, name: String, email: String, phone: String, training_level: TrainingLevel }, Location { lat: f64, lon: f64, name: String }, Booking { id: String, student_id: String, scheduled_date: DateTime<Utc>, departure_location: Location (as JSON TEXT), status: BookingStatus }, WeatherCheck { id: String, booking_id: String, checked_at: DateTime<Utc>, weather_data: String (JSON), is_safe: bool, reason: Option<String> }, RescheduleEvent { id: String, booking_id: String, original_date: DateTime<Utc>, new_date: DateTime<Utc>, suggested_by: String, ai_suggestions: Option<String> (JSON) }, WeatherMinimum { id: String, training_level: TrainingLevel, min_visibility_sm: f64, max_wind_speed_kt: f64, min_ceiling_ft: Option<f64>, allow_imc: bool, no_thunderstorms: bool, no_icing: bool }. Define enums: TrainingLevel (StudentPilot, PrivatePilot, InstrumentRated), BookingStatus (Scheduled, Cancelled, Rescheduled, Completed). Create migrations/ directory with 001_init.sql: CREATE TABLE students, bookings (with FK), weather_checks, reschedule_events, weather_minimums. Use sqlx::query! and sqlx::query_as! for type-safe queries. DATABASE_URL in .env: sqlite:///data/weather_app.db (for production) or sqlite:weather_app.db (dev).",
        "testStrategy": "Unit tests for serde JSON serialization of Location. Run `sqlx migrate run` to apply migrations. Integration tests with sqlx::test: insert Student, insert Booking with FK, query back, verify JSON deserialization. Test concurrent writes: spawn multiple tokio tasks inserting data, verify no corruption. Use `cargo sqlx prepare` for compile-time verification.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Rust structs and enums for database entities",
            "description": "Define the necessary Rust structs and enums in the core crate to represent the database entities such as Student, Location, Booking, WeatherCheck, RescheduleEvent, and WeatherMinimum, along with the enums TrainingLevel and BookingStatus.",
            "dependencies": [],
            "details": "In core/src/models.rs or similar, define the structs with the specified fields, ensuring proper derives for serde::Serialize and serde::Deserialize for JSON handling, and sqlx::FromRow for query results. Enums should derive necessary traits for database storage.",
            "status": "pending",
            "testStrategy": "Unit tests for serde JSON serialization and deserialization of Location and other complex fields to ensure correct handling of JSON TEXT in SQLite."
          },
          {
            "id": 2,
            "title": "Create SQL migration files for SQLite schema",
            "description": "Create the migrations directory and the initial migration file 001_init.sql to set up the normalized SQLite database schema with tables for students, bookings, weather_checks, reschedule_events, and weather_minimums, including foreign keys and constraints.",
            "dependencies": [
              1
            ],
            "details": "In the migrations/ directory, create 001_init.sql with CREATE TABLE statements for each entity, defining columns with appropriate types (e.g., TEXT for strings, REAL for floats, INTEGER for booleans), foreign key constraints (e.g., bookings.student_id REFERENCES students(id)), and any necessary indexes for performance.",
            "status": "pending",
            "testStrategy": "Run `sqlx migrate run` to apply the migrations and verify the schema is created correctly without errors, checking table existence and constraints via SQLite CLI or sqlx queries."
          },
          {
            "id": 3,
            "title": "Implement type-safe queries with sqlx",
            "description": "Implement compile-time type-safe queries using sqlx::query! and sqlx::query_as! for CRUD operations on the defined structs, ensuring proper integration with the SQLite database.",
            "dependencies": [
              2
            ],
            "details": "In core/src/queries.rs or relevant modules, write functions for inserting, updating, selecting, and deleting records, using sqlx macros to bind parameters and return typed results. Handle JSON serialization for fields like departure_location and weather_data using serde_json.",
            "status": "pending",
            "testStrategy": "Integration tests with sqlx::test: insert Student, insert Booking with foreign key, query back and verify data integrity including JSON deserialization. Test concurrent writes by spawning multiple tokio tasks to insert data and verify no corruption or race conditions."
          }
        ]
      },
      {
        "id": 3,
        "title": "Integrate OpenWeatherMap API for real-time weather data",
        "description": "Implement weather API client using reqwest to fetch current conditions and 7-day forecasts from OpenWeatherMap, with unit conversion and error handling.",
        "details": "In core/src/weather/api.rs, create struct WeatherClient { client: reqwest::Client, api_key: String, base_url: String }. Implement async methods: fetch_current_weather(lat: f64, lon: f64) -> Result<WeatherData> and fetch_forecast(lat: f64, lon: f64) -> Result<Vec<WeatherData>>. Define WeatherData struct: visibility_miles: f64, wind_speed_knots: f64, ceiling_ft: Option<f64>, temperature_f: f64, conditions: String, has_thunderstorms: bool, has_icing: bool, date_time: DateTime<Utc>. Parse OpenWeatherMap JSON (visibility in meters, wind in m/s) and convert: meters â†’ miles (Ã— 0.000621371), m/s â†’ knots (Ã— 1.94384), Kelvin â†’ Fahrenheit ((K - 273.15) Ã— 9/5 + 32). Check weather.main for \"Thunderstorm\", check temperature < 32Â°F && clouds for icing risk. Use dotenv to load WEATHER_API_KEY and WEATHER_API_BASE_URL from .env. Add exponential backoff retry logic (3 attempts) for network failures.",
        "testStrategy": "Unit tests with wiremock: mock OpenWeatherMap API responses, verify JSON parsing and unit conversions are correct. Test error handling: mock 404, 500, timeout responses. Integration test with real API key (optional, use #[ignore]). Property test conversions: 0 meters = 0 miles, 10 m/s â‰ˆ 19.4 knots.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define WeatherClient struct and async methods",
            "description": "Create the WeatherClient struct with reqwest::Client, api_key, and base_url fields in core/src/weather/api.rs. Implement the async methods fetch_current_weather and fetch_forecast that take latitude and longitude and return Result types.",
            "dependencies": [],
            "details": "In core/src/weather/api.rs, define the struct WeatherClient { client: reqwest::Client, api_key: String, base_url: String }. Add async fn fetch_current_weather(lat: f64, lon: f64) -> Result<WeatherData> and async fn fetch_forecast(lat: f64, lon: f64) -> Result<Vec<WeatherData>>. Use dotenv to load WEATHER_API_KEY and WEATHER_API_BASE_URL from .env file.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement JSON parsing and unit conversions",
            "description": "Parse OpenWeatherMap JSON responses and convert units: visibility from meters to miles, wind speed from m/s to knots, temperature from Kelvin to Fahrenheit. Detect thunderstorms and icing conditions.",
            "dependencies": [
              1
            ],
            "details": "Define the WeatherData struct with fields: visibility_miles, wind_speed_knots, ceiling_ft, temperature_f, conditions, has_thunderstorms, has_icing, date_time. Implement parsing logic to convert: meters * 0.000621371 to miles, m/s * 1.94384 to knots, (K - 273.15) * 9/5 + 32 to Fahrenheit. Check weather.main for 'Thunderstorm', and temperature < 32Â°F with clouds for icing.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Add error handling and exponential backoff retries",
            "description": "Implement robust error handling for network failures, including exponential backoff retry logic with up to 3 attempts for API calls.",
            "dependencies": [
              1
            ],
            "details": "Wrap API calls in retry logic using exponential backoff for network errors. Handle potential HTTP errors like 404, 500, and timeouts. Ensure the methods return appropriate Result types with custom error handling for failed requests or parsing issues.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 4,
            "title": "Write unit and property-based tests",
            "description": "Create comprehensive tests using wiremock to mock API responses, verify parsing, conversions, error handling, and include property-based tests for unit conversions.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Use wiremock to simulate OpenWeatherMap API responses. Write unit tests for successful parsing and conversions, error scenarios (404, 500, timeout), and property-based tests with proptest for conversions (e.g., 0 meters = 0 miles, 10 m/s â‰ˆ 19.4 knots). Optionally include an integration test with real API key marked as #[ignore].",
            "status": "pending",
            "testStrategy": "Unit tests with wiremock: mock OpenWeatherMap API responses, verify JSON parsing and unit conversions are correct. Test error handling: mock 404, 500, timeout responses. Integration test with real API key (optional, use #[ignore]). Property test conversions: 0 meters = 0 miles, 10 m/s â‰ˆ 19.4 knots."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement weather conflict detection with training level safety logic",
        "description": "Develop safety checking logic using pattern matching on TrainingLevel enum to determine if weather conditions are safe for flight, with configurable minimums from database.",
        "details": "In core/src/weather/safety.rs, implement fn is_flight_safe(training_level: &TrainingLevel, weather: &WeatherData, minimums: &WeatherMinimum) -> (bool, Option<String>). Return tuple of (is_safe, reason). Use match on training_level with rules from PRD: StudentPilot (clear skies, vis > minimum, winds < minimum, no low clouds <3000ft), PrivatePilot (vis > 3mi, ceiling > 1000ft, winds < 20kt), InstrumentRated (allow IMC, but no thunderstorms && no icing). Load minimums from weather_minimums table at startup, cache in memory (Arc<HashMap<TrainingLevel, WeatherMinimum>>). If weather unsafe, generate detailed reason string: 'Visibility 2.5mi below minimum 3mi for Private Pilot'. Implement fn calculate_weather_score(training_level: &TrainingLevel, weather: &WeatherData) -> f32 returning 0-10 score for AI ranking (10 = perfect conditions).",
        "testStrategy": "Unit tests for each training level with various weather scenarios. Property-based testing with proptest: generate random WeatherData, verify StudentPilot is subset of PrivatePilot (stricter rules). Test edge cases: exactly at minimums (should pass), 0.1 below minimums (should fail). Test reason strings are descriptive. Test with database-loaded minimums override hardcoded values.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Load and cache weather minimums from database",
            "description": "Implement loading of configurable weather minimums from the weather_minimums table at startup and cache them in memory using Arc<HashMap<TrainingLevel, WeatherMinimum>>.",
            "dependencies": [],
            "details": "In core/src/weather/safety.rs or a related module, add code to query the weather_minimums table using the database connection, load the minimums into a HashMap keyed by TrainingLevel, wrap in Arc for shared access, and ensure this is done at application startup. Handle potential database errors gracefully.",
            "status": "pending",
            "testStrategy": "Unit tests to verify loading from a mock database, integration tests to check caching persists across requests, and error handling tests for database failures."
          },
          {
            "id": 2,
            "title": "Implement safety checking function with pattern matching",
            "description": "Develop the is_flight_safe function using pattern matching on TrainingLevel enum to check if weather conditions are safe for flight based on PRD rules, returning a tuple of (bool, Option<String>).",
            "dependencies": [
              1
            ],
            "details": "In core/src/weather/safety.rs, implement fn is_flight_safe(training_level: &TrainingLevel, weather: &WeatherData, minimums: &WeatherMinimum) -> (bool, Option<String>). Use match on training_level with specific rules: StudentPilot (clear skies, vis > minimum, winds < minimum, no low clouds <3000ft), PrivatePilot (vis > 3mi, ceiling > 1000ft, winds < 20kt), InstrumentRated (allow IMC, but no thunderstorms && no icing). Generate detailed reason strings for unsafe conditions. Also implement fn calculate_weather_score for AI ranking.",
            "status": "pending",
            "testStrategy": "Unit tests for each training level with various weather scenarios, property-based testing to ensure StudentPilot rules are stricter than PrivatePilot, test edge cases like exactly at minimums (pass) and slightly below (fail), and verify reason strings are accurate."
          }
        ]
      },
      {
        "id": 5,
        "title": "Integrate OpenAI API for structured AI rescheduling suggestions",
        "description": "Use OpenAI chat completions API with gpt-4o-mini and structured JSON output to generate 3 reschedule options, with caching and fallback logic.",
        "details": "In core/src/ai/reschedule.rs, define structs: RescheduleOption { date_time: DateTime<Utc>, reason: String, weather_score: f32, instructor_available: bool }, RescheduleResponse { options: Vec<RescheduleOption> }. Implement async fn generate_reschedule_options(booking: &Booking, student: &Student, weather_forecast: &[WeatherData], instructor_schedule: &[Booking]) -> Result<Vec<RescheduleOption>>. Build context prompt including: student name/training_level, original booking time, departure location, 7-day weather forecast (formatted), instructor availability, weather minimums. Use reqwest to POST https://api.openai.com/v1/chat/completions with headers: Authorization: Bearer $OPENAI_API_KEY. Request body: model: 'gpt-4o-mini', messages: [{role: 'system', content: 'You are a flight scheduling assistant. Always return valid JSON.'}, {role: 'user', content: prompt}], temperature: 0.7, response_format: { type: 'json_object' }. Parse response JSON into RescheduleResponse, validate options.len() >= 3, else use fallback. Implement fallback: generate_fallback_options() that finds next 3 days with safe weather using is_flight_safe(). Implement AiCache struct with RwLock<HashMap<String, (RescheduleResponse, DateTime<Utc>)>> for 6hr TTL caching keyed by 'booking_id_scheduled_date'.",
        "testStrategy": "Unit tests with wiremock for OpenAI API: mock successful response, verify parsing. Test fallback: mock AI returning <3 options or invalid JSON. Test caching: first call misses cache (API called), second call hits cache (no API call). Integration test: provide real booking data, verify 3 valid DateTime options returned with reasons. Test cost: verify cache prevents duplicate calls for same booking.",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define RescheduleOption and RescheduleResponse structs and build context prompt",
            "description": "In core/src/ai/reschedule.rs, define the structs RescheduleOption { date_time: DateTime<Utc>, reason: String, weather_score: f32, instructor_available: bool } and RescheduleResponse { options: Vec<RescheduleOption> }. Implement the logic to build the context prompt including student name/training_level, original booking time, departure location, 7-day weather forecast (formatted), instructor availability, and weather minimums.",
            "dependencies": [],
            "details": "Ensure the structs are properly defined with serde derive for JSON serialization and deserialization. The prompt building function should take inputs like booking, student, weather_forecast, and instructor_schedule, and construct a detailed string that provides context for the AI to generate reschedule options. This includes formatting the weather data into a readable format and including all necessary details for accurate suggestions.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement OpenAI API call with reqwest and parse structured JSON response",
            "description": "Use reqwest to POST to https://api.openai.com/v1/chat/completions with headers including Authorization: Bearer $OPENAI_API_KEY. The request body should include model: 'gpt-4o-mini', messages with system and user roles, temperature: 0.7, and response_format: { type: 'json_object' }. Parse the response JSON into RescheduleResponse and validate that options.len() >= 3.",
            "dependencies": [
              1
            ],
            "details": "Implement an async function that constructs the request body using the prompt from subtask 1. Handle the HTTP response, deserialize the JSON, and validate the structure. If parsing fails or options are insufficient, prepare for fallback in the next subtask. Ensure error handling for network issues and API errors.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Implement AiCache for TTL caching and fallback options generation",
            "description": "Implement AiCache struct with RwLock<HashMap<String, (RescheduleResponse, DateTime<Utc>)>> for 6-hour TTL caching, keyed by 'booking_id_scheduled_date'. Add fallback logic: if API response is invalid or has <3 options, call generate_fallback_options() to find next 3 days with safe weather using is_flight_safe().",
            "dependencies": [
              2
            ],
            "details": "The cache should check for existing entries before making API calls and expire entries after 6 hours. The fallback function should iterate through upcoming days, check weather safety, instructor availability, and generate basic options with reasons. Integrate this into the main generate_reschedule_options function to return Vec<RescheduleOption>.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 4,
            "title": "Add unit tests with wiremock for API responses, caching, and fallback",
            "description": "Use wiremock to mock OpenAI API responses for successful parsing, invalid JSON, and insufficient options. Test caching: first call misses cache (API called), second call hits cache (no API call). Test fallback scenarios and verify parsing and validation logic.",
            "dependencies": [
              3
            ],
            "details": "Create unit tests in core/src/ai/reschedule.rs or a separate tests module. Mock various API responses including valid JSON with 3+ options, invalid JSON, and responses with fewer than 3 options. Verify that caching prevents redundant API calls and that fallback generates appropriate options. Ensure tests cover error handling and edge cases.",
            "status": "pending",
            "testStrategy": "Unit tests with wiremock for OpenAI API: mock successful response, verify parsing. Test fallback: mock AI returning <3 options or invalid JSON. Test caching: first call misses cache (API called), second call hits cache (no API call)."
          }
        ]
      },
      {
        "id": 6,
        "title": "Build WebSocket notification system with Tokio broadcast channels",
        "description": "Implement real-time push notifications using Axum WebSocket handler and tokio::sync::broadcast for pub/sub, enabling live dashboard updates.",
        "details": "In server/src/routes/websocket.rs, define type NotificationChannel = broadcast::Sender<String>. Create channel in main(): let (tx, _rx) = broadcast::channel::<String>(100); store tx in Axum State. Define WebSocket route: async fn ws_handler(ws: WebSocketUpgrade, State(tx): State<NotificationChannel>) -> Response { ws.on_upgrade(move |socket| handle_socket(socket, tx)) }. In handle_socket(), subscribe to broadcast: let mut rx = tx.subscribe(); loop: while let Ok(msg) = rx.recv().await { socket.send(Message::Text(msg)).await; }. Handle disconnects gracefully. Define notification types as JSON: WeatherConflict { type: 'WEATHER_CONFLICT', booking_id, message }, BookingCancelled, RescheduleOptionsAvailable { type: 'RESCHEDULE_OPTIONS', booking_id, options: Vec<RescheduleOption> }. When conflict detected in scheduler, serialize notification to JSON and tx.send(json_string). Add heartbeat: send Ping frames every 30s, close connection if no Pong after 60s.",
        "testStrategy": "Unit tests: create channel, send message, verify receiver gets it. Integration tests: connect WebSocket client (using tokio-tungstenite), send test notification via broadcast, verify client receives JSON message. Test multiple clients: connect 3 clients, send 1 notification, all 3 receive it. Test reconnection: disconnect client, reconnect, verify new subscription works. E2E test: trigger conflict in backend, verify WebSocket client receives notification without polling.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Tokio broadcast channel and Axum WebSocket handler",
            "description": "Create the broadcast channel in the main function and define the Axum WebSocket route handler to upgrade connections.",
            "dependencies": [],
            "details": "In server/src/routes/websocket.rs, define type NotificationChannel = broadcast::Sender<String>. In main(), create the channel: let (tx, _rx) = broadcast::channel::<String>(100); and store tx in Axum State. Define the WebSocket route: async fn ws_handler(ws: WebSocketUpgrade, State(tx): State<NotificationChannel>) -> Response { ws.on_upgrade(move |socket| handle_socket(socket, tx)) }. This sets up the foundation for pub/sub notifications.",
            "status": "pending",
            "testStrategy": "Unit tests: create channel, send message, verify receiver gets it. Integration tests: connect WebSocket client, verify upgrade works."
          },
          {
            "id": 2,
            "title": "Implement WebSocket connection handling with heartbeats",
            "description": "Handle incoming WebSocket connections, subscribe to the broadcast channel, and manage heartbeats for connection health.",
            "dependencies": [
              1
            ],
            "details": "In handle_socket(), subscribe to the broadcast: let mut rx = tx.subscribe(); then loop: while let Ok(msg) = rx.recv().await { socket.send(Message::Text(msg)).await; }. Add heartbeat logic: send Ping frames every 30 seconds, and close the connection if no Pong is received after 60 seconds. Handle disconnects gracefully to prevent resource leaks.",
            "status": "pending",
            "testStrategy": "Integration tests: connect WebSocket client, send test notification via broadcast, verify client receives JSON message. Test multiple clients: connect 3 clients, send 1 notification, all 3 receive it. Test heartbeats: simulate no Pong, verify connection closes."
          },
          {
            "id": 3,
            "title": "Define notification types and implement broadcasting",
            "description": "Define JSON notification types and implement logic to serialize and broadcast notifications when events occur.",
            "dependencies": [
              1
            ],
            "details": "Define notification types as JSON structs: WeatherConflict { type: 'WEATHER_CONFLICT', booking_id, message }, BookingCancelled, RescheduleOptionsAvailable { type: 'RESCHEDULE_OPTIONS', booking_id, options: Vec<RescheduleOption> }. When a conflict is detected in the scheduler, serialize the notification to JSON and call tx.send(json_string). Ensure broadcasting integrates with the existing scheduler logic.",
            "status": "pending",
            "testStrategy": "Unit tests: serialize notification types to JSON, verify format. Integration tests: trigger conflict in scheduler, verify notification is broadcasted and received by connected clients."
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop Elm frontend with Vite and WebSocket ports integration",
        "description": "Create Elm SPA using Vite with elm-vite-plugin for hot-reload, implementing dashboard with HTTP API calls and WebSocket ports for real-time updates.",
        "details": "In elm/ directory, structure: src/Main.elm (entry), src/Types.elm (type aliases), src/Api.elm (HTTP), src/WebSocket.elm (ports), src/Pages/Dashboard.elm, src/Pages/Bookings.elm, src/Pages/Alerts.elm. In Types.elm, define: type alias Student = { id: String, name: String, email: String, phone: String, trainingLevel: String }, type alias Booking = { id: String, studentId: String, scheduledDate: String, departureLocation: Location, status: String }, type alias Alert = { type: String, bookingId: String, message: String }. In Api.elm, use elm/http to define: getBookings : Cmd Msg, createBooking : BookingForm -> Cmd Msg, getStudents : Cmd Msg (all targeting /api/*). In WebSocket.elm, define port module: port websocketIn : (String -> msg) -> Sub msg, port websocketOut : String -> Cmd msg. In Main.elm, subscriptions: websocketIn WebSocketMessageReceived. Decode JSON from WebSocket, update model with new alerts. In main.js (Vite entry), initialize Elm app, connect WebSocket: const ws = new WebSocket('ws://localhost:3000/ws'); ws.onopen = () => app.ports.websocketOut?.subscribe(msg => ws.send(msg)); ws.onmessage = e => app.ports.websocketIn?.send(e.data); ws.onerror/onclose â†’ reconnect logic. Use elm-ui or Tailwind CSS for styling. Configure vite.config.js with elmPlugin({ debug: false, optimize: true }).",
        "testStrategy": "Run `npm run dev`, verify Elm compiles and hot-reloads work. Unit tests with elm-test for update functions: test WebSocketMessageReceived adds alert to model. Integration test: start Axum server, open Elm UI in browser, trigger backend event, verify UI updates without refresh. Test HTTP API: create booking via form, verify POST succeeds and booking appears in list. E2E with Playwright: navigate to dashboard, verify WebSocket connects (check dev console), trigger notification, assert alert appears.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Elm project structure and define types",
            "description": "Initialize the Elm project in the elm/ directory with the specified file structure, including Main.elm, Types.elm, Api.elm, WebSocket.elm, and page modules. Define all type aliases in Types.elm as specified.",
            "dependencies": [],
            "details": "Create the elm/ directory and set up src/Main.elm as the entry point, src/Types.elm for type aliases like Student, Booking, Alert, and Location. Ensure the project uses Vite with elm-vite-plugin for hot-reload. Configure vite.config.js accordingly.",
            "status": "pending",
            "testStrategy": "Run `npm run dev` to verify Elm compiles and hot-reload works without errors."
          },
          {
            "id": 2,
            "title": "Implement HTTP API calls in Api.elm",
            "description": "Use elm/http to define functions for API interactions, including getBookings, createBooking, and getStudents, targeting /api/* endpoints.",
            "dependencies": [
              1
            ],
            "details": "In src/Api.elm, implement the HTTP commands using elm/http library. Handle responses and errors appropriately, integrating with the Msg system for updating the model. Ensure commands are called from Main.elm or page modules.",
            "status": "pending",
            "testStrategy": "Unit tests with elm-test to verify API functions return expected Cmd Msg and handle mock responses correctly."
          },
          {
            "id": 3,
            "title": "Integrate WebSocket ports for real-time updates",
            "description": "Define port module in WebSocket.elm with websocketIn and websocketOut ports, and handle subscriptions in Main.elm for decoding JSON and updating the model with new alerts.",
            "dependencies": [
              1
            ],
            "details": "Create src/WebSocket.elm as a port module. In Main.elm, set up subscriptions for websocketIn to receive messages. Implement logic to decode incoming JSON and update the model with alerts. In main.js, connect to WebSocket and wire ports for sending and receiving messages, including reconnect logic.",
            "status": "pending",
            "testStrategy": "Integration test: Start a mock WebSocket server, send test messages, and verify the Elm model updates correctly via ports."
          },
          {
            "id": 4,
            "title": "Build the dashboard UI with pages and styling",
            "description": "Develop the SPA dashboard using Elm, including pages for Dashboard, Bookings, and Alerts, with elm-ui or Tailwind CSS for styling.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement src/Pages/Dashboard.elm, src/Pages/Bookings.elm, and src/Pages/Alerts.elm with views and update logic. Use elm-ui or integrate Tailwind CSS for responsive styling. Ensure the UI displays data from HTTP calls and updates in real-time via WebSockets.",
            "status": "pending",
            "testStrategy": "Manual testing: Run the app, navigate pages, verify UI renders correctly and updates with API data and WebSocket messages."
          },
          {
            "id": 5,
            "title": "Test the Elm frontend with E2E tools",
            "description": "Perform end-to-end testing using tools like Playwright to simulate user interactions and verify full workflow from booking creation to real-time updates.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Write E2E tests to cover creating bookings, checking HTTP API responses, and confirming WebSocket notifications update the UI without refresh. Use Playwright or similar to automate browser interactions.",
            "status": "pending",
            "testStrategy": "Run E2E tests with Playwright: Simulate booking creation, trigger WebSocket events, and assert UI updates in real-time."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Axum REST API endpoints and static file serving",
        "description": "Create RESTful API routes in Axum for CRUD operations on bookings/students, WebSocket upgrade endpoint, and serve Vite-built Elm frontend as static files.",
        "details": "In server/src/main.rs, define Axum Router: let app = Router::new().nest('/api', api_routes()).route('/ws', get(ws_handler)).nest_service('/', ServeDir::new('dist')).fallback(serve_spa).layer(CorsLayer::permissive()).with_state(app_state). In server/src/routes/bookings.rs, implement: async fn list_bookings(State(db): State<SqlitePool>) -> Result<Json<Vec<Booking>>>, async fn create_booking(State(db): State<SqlitePool>, Json(booking): Json<CreateBookingRequest>) -> Result<(StatusCode, Json<Booking>), StatusCode>, async fn get_booking(Path(id): Path<String>, State(db): State<SqlitePool>) -> Result<Json<Booking>>, async fn reschedule_booking(Path(id): Path<String>, State(db): State<SqlitePool>, Json(req): Json<RescheduleRequest>) -> Result<Json<Booking>>. Similar for students routes. Use validator crate for input validation. Return proper status codes: 200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error. In serve_spa fallback, return index.html for client-side routing. Use tower_http::services::ServeDir to serve Vite output from dist/. Add health check: .route('/health', get(|| async { Json(json!({ 'status': 'ok' })) })).",
        "testStrategy": "Integration tests with reqwest: start test server, call GET /api/bookings (expect 200 + JSON array), POST /api/bookings with valid data (expect 201 + created booking), POST with invalid data (expect 400). Test CORS: make request from different origin. Test static files: GET /, verify returns index.html; GET /nonexistent, verify returns index.html (SPA fallback). Use sqlx::test for database setup in tests.",
        "priority": "medium",
        "dependencies": [
          2,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement CRUD routes and handlers for bookings and students",
            "description": "Create async handler functions for listing, creating, getting, and updating bookings and students in the respective route files, including the WebSocket upgrade endpoint.",
            "dependencies": [],
            "details": "In server/src/routes/bookings.rs and server/src/routes/students.rs, implement the specified async functions using State<SqlitePool> for database access, and add the /ws route with ws_handler in main.rs.",
            "status": "pending",
            "testStrategy": "Integration tests with reqwest to verify GET /api/bookings returns 200 with JSON array, POST /api/bookings with valid data returns 201."
          },
          {
            "id": 2,
            "title": "Add input validation and error handling",
            "description": "Integrate the validator crate for validating incoming JSON requests and implement proper error responses with correct HTTP status codes.",
            "dependencies": [
              1
            ],
            "details": "Apply validation to CreateBookingRequest and similar structs, handle database errors and invalid inputs by returning StatusCode 400 for bad requests, 404 for not found, and 500 for internal errors in all handlers.",
            "status": "pending",
            "testStrategy": "Test POST endpoints with invalid data to ensure 400 Bad Request is returned, and verify error messages are appropriate."
          },
          {
            "id": 3,
            "title": "Configure static file serving, CORS, and health check",
            "description": "Set up the Axum router to serve static files from the dist/ directory, add CORS layer, implement SPA fallback, and include a health check endpoint.",
            "dependencies": [],
            "details": "In server/src/main.rs, configure the Router with nest_service for '/', ServeDir::new('dist'), fallback to serve_spa for client-side routing, add CorsLayer::permissive(), and route '/health' to return JSON status.",
            "status": "pending",
            "testStrategy": "Test GET / returns index.html, verify CORS allows cross-origin requests, and check GET /health returns {'status': 'ok'}."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement email and SMS notifications with trait abstraction",
        "description": "Create notification system with Resend for emails and trait-based Twilio integration (with mock fallback) for SMS, triggered on weather conflicts.",
        "details": "In core/src/notifications/email.rs, use reqwest to POST https://api.resend.com/emails with Authorization: Bearer $RESEND_API_KEY. Define async fn send_conflict_email(to: &str, booking: &Booking, options: &[RescheduleOption]) -> Result<()>. Use HTML email template with booking details and 3 reschedule options as buttons/links. In core/src/notifications/sms.rs, define #[async_trait] trait SmsProvider { async fn send_sms(&self, to: &str, message: &str) -> Result<()> }. Implement TwilioProvider { account_sid, auth_token, from_number, client: reqwest::Client } with send_sms() POSTing to https://api.twilio.com/2010-04-01/Accounts/{sid}/Messages.json with basic_auth. Implement MockSmsProvider with send_sms() logging via tracing::info!('ðŸ“± [MOCK SMS] To: {}, Message: {}', to, message). Create pub fn create_sms_provider() -> Box<dyn SmsProvider>: if env vars TWILIO_* exist, return Box::new(TwilioProvider::new()), else return Box::new(MockSmsProvider). Store provider in Axum State. When conflict detected: send_conflict_email() and sms_provider.send_sms().",
        "testStrategy": "Unit tests: TwilioProvider with wiremock to verify Twilio API call format, MockSmsProvider verifies tracing log output. Test factory: with env vars â†’ returns TwilioProvider, without â†’ returns MockSmsProvider. Integration test: trigger conflict, verify both email API called (wiremock) and SMS provider invoked. E2E: run app without Twilio credentials, trigger conflict, check logs for '[MOCK SMS]'.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement email sending with Resend API",
            "description": "Create the email notification functionality using the Resend API to send conflict emails with booking details and reschedule options.",
            "dependencies": [],
            "details": "In core/src/notifications/email.rs, use reqwest to POST to https://api.resend.com/emails with Authorization: Bearer $RESEND_API_KEY. Define async fn send_conflict_email(to: &str, booking: &Booking, options: &[RescheduleOption]) -> Result<()>. Implement an HTML email template that includes booking details and presents 3 reschedule options as clickable buttons or links. Ensure proper error handling for API responses and template rendering.",
            "status": "pending",
            "testStrategy": "Unit tests using wiremock to mock the Resend API, verifying the POST request format, headers, and payload structure. Test email template rendering with sample booking data and options."
          },
          {
            "id": 2,
            "title": "Implement trait-based SMS provider with Twilio and mock",
            "description": "Develop the SMS notification system using a trait abstraction for providers, including Twilio implementation and a mock fallback.",
            "dependencies": [],
            "details": "In core/src/notifications/sms.rs, define #[async_trait] trait SmsProvider { async fn send_sms(&self, to: &str, message: &str) -> Result<()> }. Implement TwilioProvider struct with fields account_sid, auth_token, from_number, and client: reqwest::Client; its send_sms method should POST to https://api.twilio.com/2010-04-01/Accounts/{sid}/Messages.json using basic auth. Implement MockSmsProvider with send_sms logging via tracing::info!('ðŸ“± [MOCK SMS] To: {}, Message: {}', to, message). Create pub fn create_sms_provider() -> Box<dyn SmsProvider> that checks for TWILIO_* env vars to return TwilioProvider or MockSmsProvider. Store the provider in Axum State for dependency injection.",
            "status": "pending",
            "testStrategy": "Unit tests: TwilioProvider with wiremock to verify Twilio API call format and authentication. MockSmsProvider tests to check tracing log output. Factory function tests: with env vars returns TwilioProvider, without returns MockSmsProvider."
          },
          {
            "id": 3,
            "title": "Integrate notifications into weather conflict detection flow",
            "description": "Modify the weather conflict detection logic to trigger email and SMS notifications when a conflict is detected.",
            "dependencies": [
              1,
              2
            ],
            "details": "Update the conflict detection code (likely in core/src/weather/safety.rs or related modules) to call send_conflict_email() and sms_provider.send_sms() when a weather conflict is identified for a booking. Ensure the notifications include relevant booking details, conflict reasons, and reschedule options. Integrate with the existing Axum State to access the SMS provider and any necessary database or booking data.",
            "status": "pending",
            "testStrategy": "Integration test: Seed database with a booking that triggers a conflict, manually run the conflict detection logic, and verify that both the email API (via wiremock) and SMS provider (Twilio or mock) are called with correct parameters. Check that notifications are sent only on conflicts."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement background weather monitoring with tokio-cron-scheduler",
        "description": "Set up hourly scheduled job using tokio-cron-scheduler to check flights in next 48hrs, detect conflicts, cancel bookings, generate AI reschedules, and send notifications.",
        "details": "In server/src/scheduler.rs, use tokio_cron_scheduler::JobScheduler. Define async fn start_weather_monitor(db: SqlitePool, notifier: NotificationChannel, sms_provider: Arc<dyn SmsProvider>, weather_client: Arc<WeatherClient>, ai_cache: Arc<AiCache>) -> Result<()>. Create scheduler: let scheduler = JobScheduler::new().await?. Define cron job: let job = Job::new_async('0 0 * * * *', move |_uuid, _lock| { let db = db.clone(); ... Box::pin(async move { check_all_flights(&db, &notifier, ...).await }) })?.add(job).await?.start().await?. In check_all_flights(): query bookings with status=Scheduled AND scheduled_date BETWEEN now() AND now()+48hours. For each booking: fetch student, fetch current weather + 7-day forecast, load weather minimums, call is_flight_safe(). If unsafe: update booking status to Cancelled in DB, insert reschedule event, generate AI options (with cache), send email notification, send SMS, broadcast WebSocket notification. Log all actions with tracing::info!. Handle errors gracefully (log, continue to next booking, don't crash scheduler). Return ConflictSummary { total_checked: usize, conflicts_found: usize }.",
        "testStrategy": "Unit tests: mock time (tokio::time::pause()), create test scheduler, fast-forward 1hr, verify job executes. Integration test: seed DB with 2 bookings (1 with bad weather forecast, 1 with good), run scheduler manually (trigger check_all_flights directly), verify: booking 1 cancelled in DB, reschedule event inserted, notifications sent (mocked), booking 2 unchanged. E2E: run full app, wait for cron tick (or manually trigger), verify full flow. Test concurrent safety: run scheduler while API requests in progress.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5,
          6,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up the scheduler and cron job",
            "description": "Initialize the tokio-cron-scheduler in server/src/scheduler.rs and define the async function start_weather_monitor with all required parameters. Create the JobScheduler instance and add an hourly cron job that calls check_all_flights asynchronously.",
            "dependencies": [],
            "details": "In server/src/scheduler.rs, define async fn start_weather_monitor(db: SqlitePool, notifier: NotificationChannel, sms_provider: Arc<dyn SmsProvider>, weather_client: Arc<WeatherClient>, ai_cache: Arc<AiCache>) -> Result<()>. Create scheduler: let scheduler = JobScheduler::new().await?. Define cron job: let job = Job::new_async('0 0 * * * *', move |_uuid, _lock| { let db = db.clone(); ... Box::pin(async move { check_all_flights(&db, &notifier, ...).await }) })?.add(job).await?.start().await?. Ensure proper error handling and logging.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement the flight checking logic",
            "description": "Develop the check_all_flights function to query bookings in the next 48 hours, check weather safety for each, and handle cancellations if unsafe, including updating DB status and inserting reschedule events.",
            "dependencies": [
              1
            ],
            "details": "In check_all_flights(): query bookings with status=Scheduled AND scheduled_date BETWEEN now() AND now()+48hours. For each booking: fetch student, fetch current weather + 7-day forecast, load weather minimums, call is_flight_safe(). If unsafe: update booking status to Cancelled in DB, insert reschedule event. Log all actions with tracing::info!. Handle errors gracefully (log, continue to next booking, don't crash scheduler). Return ConflictSummary { total_checked: usize, conflicts_found: usize }.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked DB and weather client to verify querying, safety checks, and DB updates."
          },
          {
            "id": 3,
            "title": "Integrate notifications and AI rescheduling",
            "description": "In the flight checking logic, integrate AI option generation using cache, and trigger email, SMS, and WebSocket notifications upon detecting unsafe weather conditions.",
            "dependencies": [
              2
            ],
            "details": "For each unsafe booking: generate AI options (with cache), send email notification via Resend, send SMS via SmsProvider, broadcast WebSocket notification via notifier. Ensure all notifications include booking details and reschedule options. Handle errors in notifications without failing the job. Integrate with existing notification traits and AI cache from dependencies.",
            "status": "pending",
            "testStrategy": "Integration tests with wiremock for email/SMS APIs, verify AI cache usage, and check WebSocket broadcasts."
          },
          {
            "id": 4,
            "title": "Test the scheduler implementation",
            "description": "Create unit and integration tests for the scheduler to ensure it runs hourly, processes bookings correctly, and handles conflicts as expected.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Unit tests: mock time (tokio::time::pause()), create test scheduler, fast-forward 1hr, verify job executes. Integration test: seed DB with 2 bookings (1 with bad weather forecast, 1 with good), run scheduler manually (trigger check_all_flights directly), verify: booking 1 cancelled in DB, reschedule event inserted, notifications sent, AI options generated. Test error handling: simulate DB failures, ensure scheduler continues.",
            "status": "pending",
            "testStrategy": "Use tokio::time::pause() for time mocking, wiremock for external APIs, and assert on DB state and notification calls."
          }
        ]
      },
      {
        "id": 11,
        "title": "Conduct comprehensive testing with coverage reporting",
        "description": "Run unit, integration, property-based, and end-to-end tests covering all PRD success criteria, with 80%+ code coverage for core logic.",
        "details": "Use cargo test for all Rust tests. Unit tests: core/src/**/tests.rs modules for safety logic, AI prompt building, weather parsing, notification formatting. Property-based tests with proptest: generate random WeatherData/TrainingLevel combos, verify safety logic consistency. Integration tests: tests/ directory with wiremock for external APIs (OpenWeatherMap, OpenAI, Resend, Twilio), sqlx::test for DB. WebSocket tests: spawn test server, connect with tokio-tungstenite client, verify broadcast. E2E tests with Playwright (elm/e2e/): test_create_booking_and_conflict.spec.ts: navigate to dashboard, fill booking form, submit, mock weather API to return bad weather, trigger manual check, verify real-time alert appears, verify 3 reschedule options displayed, click option, verify booking updated. Run cargo-tarpaulin for coverage: cargo tarpaulin --out Html --output-dir coverage --exclude-files 'server/src/main.rs' 'tests/*' --target-dir target/tarpaulin (exclude main and test files). Target: 80%+ coverage for core/ crate. Test concurrent DB access: spawn 10 tokio tasks simultaneously inserting/querying, verify no corruption (use PRAGMA journal_mode=WAL in SQLite).",
        "testStrategy": "All PRD tests pass: weather API integration (mocked JSON parsing), safety logic (property-based with proptest), AI output (structured JSON with >=3 options), notifications (email/SMS/WebSocket mocks), dashboard UI (Playwright E2E), database (audit trail + concurrent writes), scheduler (cron execution + conflict handling), WebSocket (reconnection + backpressure). Generate coverage report, ensure core safety logic >90%, overall >80%. CI: run tests on every PR.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement unit and property-based tests",
            "description": "Run unit tests for core components like safety logic, AI prompt building, weather parsing, and notification formatting, along with property-based tests to verify consistency.",
            "dependencies": [],
            "details": "Use cargo test to execute unit tests located in core/src/**/tests.rs modules. For property-based tests, utilize proptest to generate random combinations of WeatherData and TrainingLevel, ensuring safety logic behaves consistently across scenarios.",
            "status": "pending",
            "testStrategy": "Verify that all unit tests pass and property-based tests confirm safety logic consistency without failures."
          },
          {
            "id": 2,
            "title": "Implement integration tests with mocks",
            "description": "Run integration tests for external API interactions and database operations using mocks.",
            "dependencies": [
              1
            ],
            "details": "Place integration tests in the tests/ directory. Use wiremock to mock external APIs such as OpenWeatherMap, OpenAI, Resend, and Twilio. Employ sqlx::test for database-related tests to ensure proper interactions.",
            "status": "pending",
            "testStrategy": "Mock API responses and verify that the application correctly handles requests, parses data, and interacts with the database without real external calls."
          },
          {
            "id": 3,
            "title": "Implement WebSocket and end-to-end tests",
            "description": "Test WebSocket broadcasting functionality and perform end-to-end tests covering the full user workflow.",
            "dependencies": [
              2
            ],
            "details": "For WebSocket tests, spawn a test server and connect using tokio-tungstenite to verify broadcast messages. For E2E tests, use Playwright in elm/e2e/ with test_create_booking_and_conflict.spec.ts to simulate user actions like creating bookings, triggering weather checks, and verifying real-time alerts and rescheduling.",
            "status": "pending",
            "testStrategy": "Ensure WebSocket connections broadcast correctly and E2E tests pass all steps, including UI interactions, API responses, and real-time updates."
          },
          {
            "id": 4,
            "title": "Generate code coverage report",
            "description": "Run coverage analysis to ensure at least 80% code coverage for the core logic.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Execute cargo tarpaulin with the command: cargo tarpaulin --out Html --output-dir coverage --exclude-files 'server/src/main.rs' 'tests/*' --target-dir target/tarpaulin. Focus on achieving 80%+ coverage specifically for the core/ crate.",
            "status": "pending",
            "testStrategy": "Review the generated HTML report to confirm coverage metrics exceed 80% for core logic, excluding main and test files."
          },
          {
            "id": 5,
            "title": "Set up CI for automated testing",
            "description": "Configure continuous integration to automatically run all tests and coverage reporting.",
            "dependencies": [
              4
            ],
            "details": "Set up a CI pipeline (e.g., using GitHub Actions) to execute cargo test for unit, property-based, and integration tests, run WebSocket and E2E tests, and generate coverage reports on each push or pull request.",
            "status": "pending",
            "testStrategy": "Verify that the CI pipeline passes all tests, achieves required coverage, and fails builds if thresholds are not met."
          }
        ]
      },
      {
        "id": 12,
        "title": "Deploy to Fly.io with persistent SQLite volume and monitoring",
        "description": "Create Fly.io configuration, build Docker image with Rust binary and Elm static assets, deploy with persistent volume for SQLite, configure secrets, and verify production deployment.",
        "details": "Create fly.toml: app = 'weather-event-app', primary_region = 'lax', [build] builder = 'paketobuildpacks/builder:base', [mounts] source = 'weather_app_data' destination = '/data', [[services]] internal_port = 3000 protocol = 'tcp', [[services.ports]] port = 80/443 handlers = ['http'/'tls', 'http'], [[services.http_checks]] interval = '30s' timeout = '5s' path = '/health'. Create Dockerfile (multi-stage): Stage 1: FROM node:20 AS elm-builder, copy elm/, run npm install && npm run build (outputs to elm/dist/). Stage 2: FROM rust:1.75 AS rust-builder, copy core/ and server/, copy elm/dist/ to server/dist/, cargo build --release. Stage 3: FROM debian:bookworm-slim, install ca-certificates and libsqlite3-0, copy binary and dist/ from rust-builder, EXPOSE 3000, CMD ['/app/server']. Configure server to use DATABASE_URL from env (sqlite:///data/weather_app.db in production). Run fly launch (creates app), fly volumes create weather_app_data --size 1 --region lax. Set secrets: fly secrets set OPENAI_API_KEY=sk-proj-... WEATHER_API_KEY=... RESEND_API_KEY=... RUST_LOG=info,weather_event=debug FROM_EMAIL=alerts@flightschedulepro.com. Deploy: fly deploy. Test: curl https://weather-event-app.fly.dev/health (expect {status: ok}), open https://weather-event-app.fly.dev in browser (verify Elm UI loads), open dev tools (verify WebSocket connects to wss://weather-event-app.fly.dev/ws). Create test booking via UI, verify saves to DB. Check fly logs to verify scheduler runs hourly. Measure cold start: fly apps restart, time first request (<30s target).",
        "testStrategy": "Verify fly deploy succeeds with exit code 0. Health check returns 200 OK. Access deployed URL, verify Elm UI loads, no console errors, WebSocket status = connected. Create test booking, verify API responds 201 and booking persists (restart app, check still exists â†’ volume persistence verified). Trigger manual weather check with bad mock data, verify email sent, WebSocket notification received in browser. Check fly logs: verify scheduler logs 'Running hourly weather check', verify no crashes. Test DNS: nslookup weather-event-app.fly.dev resolves. Test HTTPS: verify certificate valid. Monitor: fly dashboard for CPU/memory usage <50% under normal load. Test scaling: fly scale count 2, verify both instances serve traffic (optional).",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Docker image and Fly.io configuration",
            "description": "Build a multi-stage Docker image for the Rust binary and Elm static assets, and set up the Fly.io configuration file (fly.toml) with app settings, build options, mounts, and services.",
            "dependencies": [],
            "details": "Create a Dockerfile with three stages: Stage 1 uses node:20 to build Elm assets (copy elm/, run npm install && npm run build, output to elm/dist/). Stage 2 uses rust:1.75 to build the Rust server (copy core/ and server/, copy elm/dist/ to server/dist/, run cargo build --release). Stage 3 uses debian:bookworm-slim, installs ca-certificates and libsqlite3-0, copies the binary and dist/ from Stage 2, exposes port 3000, and sets CMD ['/app/server']. Create fly.toml with app='weather-event-app', primary_region='lax', [build] builder='paketobuildpacks/builder:base', [mounts] source='weather_app_data' destination='/data', [[services]] internal_port=3000 protocol='tcp', [[services.ports]] port=80/443 handlers=['http'/'tls', 'http'], [[services.http_checks]] interval='30s' timeout='5s' path='/health'. Configure the server to use DATABASE_URL from environment (sqlite:///data/weather_app.db in production).",
            "status": "pending",
            "testStrategy": "Verify Docker build succeeds with no errors, and fly.toml validates correctly using fly config validate."
          },
          {
            "id": 2,
            "title": "Set up persistent volumes and configure secrets",
            "description": "Create a persistent volume for SQLite data on Fly.io and set up necessary environment secrets for the application.",
            "dependencies": [],
            "details": "Run fly launch to create the Fly.io app. Then, create the volume with fly volumes create weather_app_data --size 1 --region lax. Set secrets using fly secrets set for OPENAI_API_KEY, WEATHER_API_KEY, RESEND_API_KEY, RUST_LOG=info,weather_event=debug, and FROM_EMAIL=alerts@flightschedulepro.com. Ensure the server code reads these secrets from the environment variables.",
            "status": "pending",
            "testStrategy": "Check that fly volumes list shows the created volume, and fly secrets list confirms all secrets are set without exposing values."
          },
          {
            "id": 3,
            "title": "Deploy to production and verify deployment",
            "description": "Deploy the application to Fly.io and perform verification tests to ensure the production setup works correctly, including health checks, UI loading, WebSocket connections, and data persistence.",
            "dependencies": [],
            "details": "Run fly deploy to deploy the application. After deployment, test the health endpoint with curl https://weather-event-app.fly.dev/health (expect {status: ok}). Open https://weather-event-app.fly.dev in a browser to verify the Elm UI loads, check browser dev tools for WebSocket connection to wss://weather-event-app.fly.dev/ws. Create a test booking via the UI and verify it saves to the database. Restart the app with fly apps restart and check that the booking persists, confirming volume persistence. Check fly logs to ensure the scheduler runs hourly. Measure cold start time for the first request after restart, targeting under 30 seconds.",
            "status": "pending",
            "testStrategy": "Verify fly deploy exits with code 0. Health check returns 200 OK. UI loads without console errors, WebSocket status is connected. Test booking creation and persistence after app restart. Confirm scheduler logs show hourly runs. Measure and log cold start time."
          }
        ]
      },
      {
        "id": 13,
        "title": "Create demo video and comprehensive documentation",
        "description": "Record 5-10 minute demo video showing full workflow from booking to conflict to reschedule, and write detailed README with setup, deployment, and architecture documentation.",
        "details": "Demo video must show (screen recording with voiceover): 1) Open https://weather-event-app.fly.dev in browser, 2) Navigate to dashboard, show clean UI, 3) Click 'Create Booking', fill form (student: John Doe - Student Pilot, date: tomorrow 2pm, location: KTOA), submit, 4) Show booking appears in list with status 'Scheduled', 5) Simulate weather conflict: either wait for hourly scheduler or trigger manual check via hidden admin endpoint, 6) Show real-time WebSocket notification appears in UI without refresh (red alert banner: 'Flight cancelled due to weather'), 7) Show booking status changes to 'Cancelled' in real-time, 8) Show AI-generated reschedule options (3 cards with date/time, weather score, reason like 'Clear skies, 5kt winds, instructor available'), 9) Show email notification in inbox (screenshot), 10) Show terminal logs of mock SMS sent, 11) Click reschedule option, verify booking updates to new date with status 'Rescheduled', 12) Show mobile responsive design (resize browser to phone width). README.md sections: ## Overview (elevator pitch), ## Architecture (diagram showing Elm â†” Axum â†” SQLite â†” APIs), ## Tech Stack (list with versions), ## Prerequisites (Rust 1.75+, Node 20+, Elm 0.19, Fly.io CLI), ## Local Development (clone repo, copy .env.template to .env, add API keys, npm install && npm run dev in elm/, cargo run in server/), ## Database Setup (sqlx migrate run, seed data script), ## Environment Variables (document all from .env.template), ## Testing (cargo test, npm run test:e2e), ## Deployment (fly deploy steps), ## API Documentation (list endpoints with curl examples), ## Cost Analysis (breakdown per service), ## Future: Tauri Desktop Wrapper (mention stretch goal). Add architecture diagrams (mermaid in markdown).",
        "testStrategy": "Demo video review: verify all 12 steps shown clearly, audio quality good, <10 minutes. Peer review video for clarity. README test: fresh clone, follow exact steps, verify app runs locally (npm run dev + cargo run work). Test all curl examples in API docs section. Verify all links in README work. Check typos with grammar checker. Get feedback from non-technical user on README clarity.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Record Demo Video Showing Full Workflow",
            "description": "Record a 5-10 minute screen recording with voiceover demonstrating the complete workflow from booking creation to weather conflict detection, real-time notifications, reschedule options, and mobile responsiveness.",
            "dependencies": [],
            "details": "Use screen recording software to capture the browser at https://weather-event-app.fly.dev. Follow the exact steps: open site, navigate dashboard, create booking (John Doe, tomorrow 2pm, KTOA), show scheduled status, simulate conflict via admin endpoint, demonstrate WebSocket notifications, status changes, AI reschedule options, email screenshot, SMS logs, reschedule action, and mobile resize. Ensure voiceover explains each step clearly, total under 10 minutes.",
            "status": "pending",
            "testStrategy": "Demo video review: verify all 12 steps shown clearly, audio quality good, <10 minutes. Peer review video for clarity."
          },
          {
            "id": 2,
            "title": "Write and Test Comprehensive README Documentation",
            "description": "Create a detailed README.md file with sections on overview, architecture, tech stack, prerequisites, local development, database setup, environment variables, testing, deployment, API documentation, cost analysis, and future plans including diagrams.",
            "dependencies": [],
            "details": "Write README.md with specified sections: Overview (elevator pitch), Architecture (Mermaid diagram: Elm â†” Axum â†” SQLite â†” APIs), Tech Stack (with versions), Prerequisites (Rust 1.75+, etc.), Local Development (clone, .env, npm install, cargo run), Database Setup (migrations, seed), Environment Variables (from .env.template), Testing (cargo test, e2e), Deployment (fly deploy), API Docs (endpoints with curl), Cost Analysis, Future (Tauri). Include Mermaid diagrams in markdown.",
            "status": "pending",
            "testStrategy": "README test: fresh clone, follow exact steps, verify app runs locally (npm run dev + cargo run work). Test all curl examples in API docs section. Verify all links in README work."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-07T17:43:58.357Z",
      "updated": "2025-11-07T19:00:00.000Z",
      "description": "Tasks for Rust + Elm + Axum + Fly.io Weather Cancellation System (Web-First with Tauri Compatibility)"
    }
  },
  "next": {
    "tasks": [
      {
        "id": 1,
        "title": "Enhance WebSocket Infrastructure",
        "description": "Implement robust WebSocket connection management with automatic reconnection, status indicators, and resilient message handling.",
        "details": "In the Elm frontend, extend the WebSocket module to handle connection states (Connecting, Connected, Disconnected), implement exponential backoff reconnection (starting at 1s, doubling up to 16s, max 10 attempts), and add a message queue for buffering during disconnects (up to 50 messages). On the Rust backend, update the WebSocket handler to include ping/pong heartbeats every 30s, detect disconnections after 60s without pong, and manage client connections. Use tokio for async tasks. Ensure the infrastructure supports broadcasting to all clients and handles reconnections seamlessly.",
        "testStrategy": "Unit tests for reconnection logic in Elm (simulate connection drops and verify backoff delays). Integration tests for WebSocket handler in Rust (mock ping/pong and verify disconnections). E2E tests to confirm status updates and message queuing during network interruptions.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend Elm Frontend WebSocket Module",
            "description": "Enhance the Elm WebSocket module to manage connection states, implement automatic reconnection with exponential backoff, and add message queuing for resilience during disconnections.",
            "dependencies": [],
            "details": "In the Elm frontend, update the WebSocket module to track states: Connecting, Connected, Disconnected. Implement reconnection logic with exponential backoff starting at 1 second, doubling up to 16 seconds, limited to 10 attempts. Add a message queue to buffer up to 50 messages during disconnects, ensuring seamless message handling upon reconnection.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update Rust Backend WebSocket Handler",
            "description": "Modify the Rust WebSocket handler to incorporate ping/pong heartbeats, disconnection detection, and client connection management using tokio for async operations.",
            "dependencies": [],
            "details": "On the Rust backend, enhance the WebSocket handler to send ping messages every 30 seconds and detect disconnections after 60 seconds without a pong response. Implement client connection management, including broadcasting to all clients and handling reconnections. Utilize tokio for asynchronous tasks to ensure efficient and resilient WebSocket operations.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Conduct Integration Testing for WebSocket Features",
            "description": "Perform integration tests to verify the interaction between Elm frontend and Rust backend WebSocket components, including reconnection and message handling.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up integration tests that simulate WebSocket connections, disconnections, and reconnections. Test the ping/pong mechanism, message queuing, and broadcasting functionality. Ensure tests cover cross-language interactions and validate that the system handles network interruptions gracefully without data loss.",
            "status": "pending",
            "testStrategy": "Integration tests for WebSocket handler in Rust (mock ping/pong and verify disconnections). Unit tests for reconnection logic in Elm (simulate connection drops and verify backoff delays).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Execute End-to-End Testing for WebSocket Resilience",
            "description": "Run E2E tests to confirm the overall robustness of the WebSocket infrastructure under real-world conditions, focusing on status indicators and message queuing during disruptions.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement E2E tests that simulate network interruptions, verify status indicator updates (Connecting, Connected, Disconnected), and ensure message queuing works correctly during disconnections. Test full user flows, including page navigation persistence and reactive updates based on WebSocket events, to guarantee seamless user experience.",
            "status": "pending",
            "testStrategy": "E2E tests to confirm status updates and message queuing during network interruptions. Include manual disconnection simulations and verify persistence across page navigation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break this task into subtasks covering Elm frontend WebSocket module extensions (connection states, reconnection logic, message queuing), Rust backend handler updates (ping/pong heartbeats, disconnection detection, client management), integration testing, and E2E testing for resilience."
      },
      {
        "id": 2,
        "title": "Implement Connection Status Indicator",
        "description": "Add a visual WebSocket connection status indicator to inform users of real-time update availability.",
        "details": "In Elm, add a `[data-testid=\"ws-status\"]` element to the UI, typically in the header or footer, that displays the current WebSocketStatus (Connecting: yellow dot with 'Connecting...', Connected: green dot with 'â— Live', Disconnected: red dot with 'â—‹ Disconnected'). Update the model to track websocketStatus and reflect changes in the view. Ensure the indicator persists across page navigation and updates reactively based on WebSocket events.",
        "testStrategy": "Unit tests for status display logic in Elm. E2E tests to verify the indicator updates correctly on connection changes, including manual disconnection simulations.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define WebSocketStatus Type and Update Model",
            "description": "Define a WebSocketStatus union type in Elm with variants for Connecting, Connected, and Disconnected, and add a websocketStatus field to the application model to track the current connection state.",
            "dependencies": [],
            "details": "In the Elm codebase, create a new module or extend an existing one to define the WebSocketStatus type as a union type. Update the main model record to include a field like websocketStatus : WebSocketStatus, initialized to Connecting or Disconnected based on initial state. Ensure this integrates with the existing model structure without breaking other parts.",
            "status": "pending",
            "testStrategy": "Unit tests to verify the model updates correctly when websocketStatus is set to different values.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Status Indicator View Component",
            "description": "Create a view function that renders the connection status indicator based on the current WebSocketStatus, using colored dots and text as specified.",
            "dependencies": [
              1
            ],
            "details": "In Elm, implement a function like viewStatusIndicator : WebSocketStatus -> Html msg that returns a div with [data-testid=\"ws-status\"] containing a colored dot (yellow for Connecting, green for Connected, red for Disconnected) and corresponding text ('Connecting...', 'â— Live', 'â—‹ Disconnected'). Use Elm's Html attributes for styling and ensure it's a reusable component.",
            "status": "pending",
            "testStrategy": "Unit tests for the view function to check correct rendering for each status variant.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Handle WebSocket Events to Update Status",
            "description": "Update the Elm application to react to WebSocket connection events (connect, disconnect, error) by dispatching messages that update the websocketStatus in the model.",
            "dependencies": [
              1
            ],
            "details": "Extend the Elm update function to handle new messages like WebSocketConnected, WebSocketDisconnected, etc., which set the model.websocketStatus accordingly. Integrate this with the existing WebSocket subscription or port handling to ensure the status updates reactively based on actual connection changes.",
            "status": "pending",
            "testStrategy": "Unit tests for the update function to verify status changes on different WebSocket messages.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Indicator into Main UI Layout",
            "description": "Add the status indicator to the main application view, placing it in the header or footer as specified, ensuring it persists across page navigation.",
            "dependencies": [
              2,
              3
            ],
            "details": "Modify the main view function in Elm to include the status indicator component in a fixed position like the header or footer. Use Elm's layout system to ensure it remains visible and updates with the model state during navigation between pages or routes.",
            "status": "pending",
            "testStrategy": "E2E tests to verify the indicator appears in the UI and updates correctly on page changes.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Styling and Responsiveness for Indicator",
            "description": "Apply CSS or inline styles to the indicator for proper visual representation and ensure it works on different screen sizes.",
            "dependencies": [
              2
            ],
            "details": "In Elm, use style attributes or integrate with CSS to set colors, fonts, and positioning for the dots and text. Make sure the indicator is responsive, perhaps hiding text on small screens while keeping the dot visible, and test for accessibility.",
            "status": "pending",
            "testStrategy": "Visual tests or E2E tests to confirm styling matches specifications across devices.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a straightforward UI component with reactive updates."
      },
      {
        "id": 3,
        "title": "Develop Comprehensive Error Handling System",
        "description": "Implement user-friendly error messages, recovery options, and handling for all error scenarios including API failures, timeouts, and validation.",
        "details": "In Elm, create a centralized error handling module that maps HTTP errors to user-friendly messages (e.g., 400: 'Invalid request. Please check your input.'). Add `[data-testid=\"error-message\"]` for displaying errors at the top of content, with auto-dismiss after 10s. Handle network timeouts (30s), rate limiting (429), and malformed responses. On the Rust backend, standardize error responses with ErrorResponse struct, implement rate limiting middleware (100 req/min per IP using Redis), and ensure all endpoints return consistent error formats. Add retry logic for transient errors.",
        "testStrategy": "Unit tests for error message mapping in Elm. Backend tests for rate limiting and error serialization in Rust. E2E tests for various error scenarios (network failure, 500 errors) to ensure messages display and app remains functional.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Elm Error Handling Module",
            "description": "Create a centralized error handling module in Elm that maps HTTP errors to user-friendly messages, handles UI display with auto-dismiss, and manages network timeouts and rate limiting.",
            "dependencies": [],
            "details": "In Elm, develop a module to map HTTP status codes (e.g., 400 to 'Invalid request. Please check your input.') and display errors using [data-testid=\"error-message\"] at the top of content with auto-dismiss after 10 seconds. Include handling for 30-second timeouts, 429 rate limiting, and malformed responses. Ensure the module integrates with the app's model and view for reactive updates.",
            "status": "pending",
            "testStrategy": "Unit tests for error message mapping and UI display logic in Elm, including auto-dismiss functionality.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Standardize Rust Backend Error Handling",
            "description": "Implement standardized error responses, rate limiting middleware, and retry logic in the Rust backend to handle API failures, timeouts, and validation errors consistently.",
            "dependencies": [],
            "details": "In Rust, create an ErrorResponse struct for consistent error formats across all endpoints. Implement rate limiting middleware using Redis (100 req/min per IP). Add retry logic for transient errors. Ensure atomic operations and integration with existing API logic for robust error handling.",
            "status": "pending",
            "testStrategy": "Unit tests for error serialization and rate limiting in Rust. Integration tests for retry logic and middleware functionality.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide into subtasks for Elm error handling module (message mapping, UI display, auto-dismiss) and Rust backend error standardization (middleware, rate limiting, retry logic)."
      },
      {
        "id": 4,
        "title": "Add Loading States and User Feedback Components",
        "description": "Provide visual feedback during asynchronous operations with loading indicators, disabled buttons, and success messages.",
        "details": "In Elm, integrate loading spinners (`[data-testid=\"loading-spinner\"]` inline next to buttons) and disable submit buttons during processing, changing text (e.g., 'Create Student' to 'Creating...'). Add success messages (`[data-testid=\"success-message\"]` with green styling, auto-dismiss after 5s). Implement optimistic updates for lists (add items immediately, revert on failure). For page-level loading, use skeleton screens. Ensure all async operations (form submissions, data fetches) show appropriate feedback.",
        "testStrategy": "Unit tests for loading state toggles and success message display in Elm. E2E tests to verify spinners appear during form submissions, buttons disable, and success messages show after operations.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Loading Spinner Integration",
            "description": "Add loading spinners inline next to buttons during asynchronous operations.",
            "dependencies": [],
            "details": "In Elm, modify button components to conditionally render a loading spinner with [data-testid=\"loading-spinner\"] when the operation is in progress. Ensure the spinner is positioned inline and styled appropriately.",
            "status": "pending",
            "testStrategy": "Unit tests for spinner visibility based on loading state in Elm components.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Disable Submit Buttons and Update Text",
            "description": "Disable submit buttons during processing and change their text to indicate ongoing action.",
            "dependencies": [
              1
            ],
            "details": "Update Elm button components to disable them and change text (e.g., 'Create Student' to 'Creating...') when async operations are active. Use model flags to track processing states.",
            "status": "pending",
            "testStrategy": "Unit tests for button state changes and E2E tests to verify buttons are disabled during form submissions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Success Messages with Auto-Dismiss",
            "description": "Implement success messages that appear after successful operations and auto-dismiss after 5 seconds.",
            "dependencies": [
              2
            ],
            "details": "Create a success message component in Elm with [data-testid=\"success-message\"], green styling, and a timer for auto-dismissal. Integrate it into the view after async successes.",
            "status": "pending",
            "testStrategy": "Unit tests for message display and dismissal timing in Elm.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Optimistic Updates for Lists",
            "description": "Add items to lists immediately on user action and revert on failure.",
            "dependencies": [
              3
            ],
            "details": "In Elm, update the model to add items optimistically to lists upon submission, and handle reverts by removing them if the async operation fails. Ensure UI reflects changes instantly.",
            "status": "pending",
            "testStrategy": "Unit tests for list updates and reverts in Elm, plus E2E tests for optimistic behavior during data fetches.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Skeleton Screens for Page-Level Loading",
            "description": "Use skeleton screens to indicate loading for entire pages or sections.",
            "dependencies": [
              4
            ],
            "details": "Implement skeleton screen components in Elm for page-level loading states, replacing content with placeholders during data fetches. Ensure they match the layout of the actual content.",
            "status": "pending",
            "testStrategy": "Unit tests for skeleton rendering and E2E tests to verify they appear during page loads.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is UI-focused with optimistic updates and spinners."
      },
      {
        "id": 5,
        "title": "Enhance Form Validation",
        "description": "Implement comprehensive client-side and server-side validation with real-time feedback and actionable error messages.",
        "details": "In Elm, add real-time validation on field blur for forms (Student: name min 2 chars, email valid format; Booking: start/end time validation, airport code regex). Display errors below fields (`[data-testid=\"error-{fieldname}\"]`). Disable submit buttons on validation errors. On the Rust backend, use validation crates (e.g., validator) for server-side checks, including aircraft availability and instructor checks. Ensure validation prevents invalid submissions and provides specific messages.",
        "testStrategy": "Unit tests for validation functions in Elm (e.g., validateEmail). Backend tests for validation logic in Rust. E2E tests for form submissions with invalid data to confirm errors display and prevent submission.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Client-Side Form Validation in Elm",
            "description": "Add real-time validation on field blur for Student and Booking forms, including name minimum length, email format, start/end time validation, and airport code regex. Display errors below fields using specific test IDs and disable submit buttons on errors.",
            "dependencies": [],
            "details": "In the Elm frontend, extend the form modules to include validation logic that triggers on blur events. For Student form: validate name (min 2 chars) and email (valid format). For Booking form: validate start/end times (end after start) and airport codes (regex pattern). Render error messages below each field using [data-testid=\"error-{fieldname}\"] selectors. Update the model to track validation states and disable submit buttons when errors are present. Ensure real-time feedback without blocking user input.",
            "status": "pending",
            "testStrategy": "Unit tests for validation functions in Elm, such as validateEmail and validateTimes. E2E tests for form interactions to confirm errors display on blur and submit is disabled with invalid data.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Server-Side Form Validation in Rust",
            "description": "Use validation crates in Rust backend to perform server-side checks for forms, including business logic like aircraft availability and instructor checks, with specific error messages to prevent invalid submissions.",
            "dependencies": [],
            "details": "On the Rust backend, integrate validation crates like 'validator' to validate incoming form data. Implement checks for Student (name, email) and Booking (times, airport codes, plus aircraft availability and instructor availability). Return structured error responses with specific messages. Ensure validation runs before processing submissions and integrates with existing API endpoints. Use async handling for database checks on availability.",
            "status": "pending",
            "testStrategy": "Unit tests for validation logic in Rust, including mock database checks. Integration tests for API endpoints with invalid data. E2E tests to verify error messages are returned and invalid submissions are blocked.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into subtasks for Elm client-side validation (real-time feedback, field errors) and Rust server-side validation (using crates, business logic checks)."
      },
      {
        "id": 6,
        "title": "Implement Weather Alert Banner and Display Logic",
        "description": "Create a component to display real-time weather alerts with severity-based styling and dismissal functionality.",
        "details": "In Elm, build WeatherAlertBanner.elm to show alerts as stacked banners at the top (`[data-testid=\"weather-alert\"]`), with severity colors (Severe: red, etc.), and dismiss buttons. Handle multiple alerts (max 5, auto-dismiss oldest). Update dashboard stats (`[data-testid=\"stat-alerts\"]`) with active count. Persist alerts in model across navigation. Integrate with WebSocket to receive and display alerts in the specified JSON format.",
        "testStrategy": "Unit tests for alert rendering and dismissal in Elm. E2E tests to simulate WebSocket alert messages and verify banners appear, stats update, and persistence across pages.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Alert Data Model and Types",
            "description": "Create Elm types for weather alerts, including severity levels, message content, and unique identifiers to support the banner component.",
            "dependencies": [],
            "details": "In WeatherAlertBanner.elm, define a custom type for Alert with fields like id (String), severity (Severe | Moderate | Minor), message (String), and timestamp. Ensure the model includes a list of active alerts and integrates with the overall app model for persistence.\n<info added on 2025-11-10T18:41:35.208Z>\nImplemented Severity union type in Types.elm with 5 levels: Severe, High, Moderate, Low, Clear. Type-safe design prevents invalid states.\n</info added on 2025-11-10T18:41:35.208Z>",
            "status": "pending",
            "testStrategy": "Unit tests to verify type definitions and basic alert creation.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Alert Banner View with Severity Styling",
            "description": "Build the UI component to render stacked alert banners at the top of the page with color-coded severity styling.",
            "dependencies": [
              1
            ],
            "details": "In the view function of WeatherAlertBanner.elm, create HTML elements with [data-testid=\"weather-alert\"] for each alert, applying CSS classes for red (Severe), orange (Moderate), yellow (Minor), and including the alert message. Stack them vertically at the top of the dashboard.\n<info added on 2025-11-10T18:41:50.921Z>\nImplemented severityDecoder in Api.elm using andMap pattern. Parses JSON severity strings (case-insensitive) with graceful fallback to Moderate. Enhanced alertDecoder with backward compatibility using Decode.oneOf for optional fields.\n</info added on 2025-11-10T18:41:50.921Z>",
            "status": "pending",
            "testStrategy": "Unit tests for view rendering with different severities and E2E tests to check visual appearance.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Dismissal Functionality and Alert Management",
            "description": "Implement buttons to dismiss individual alerts and logic to limit to max 5 alerts, auto-dismissing the oldest when exceeded.",
            "dependencies": [
              1
            ],
            "details": "Add dismiss buttons to each banner in the view, updating the model to remove dismissed alerts. In the update function, enforce a maximum of 5 alerts by removing the oldest (based on timestamp) when a new one is added. Ensure the list is sorted by severity or timestamp for display.\n<info added on 2025-11-10T18:42:02.418Z>\nImplemented enhanced viewAlert function in Main.elm (lines 460-533) with severity icons, CSS classes, location/timestamp display, and test IDs. Added formatTimestamp helper for ISO 8601 conversion. Updated DismissAlert handler to use alert IDs.\n</info added on 2025-11-10T18:42:02.418Z>",
            "status": "pending",
            "testStrategy": "Unit tests for dismissal logic and alert limit enforcement, including edge cases like adding the 6th alert.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update Dashboard Stats with Active Alert Count",
            "description": "Modify the dashboard to display the count of active alerts in the stats section.",
            "dependencies": [
              1,
              3
            ],
            "details": "In the main dashboard view, update the [data-testid=\"stat-alerts\"] element to show the length of the active alerts list from the model. Ensure this updates reactively when alerts are added or dismissed, and persists across page navigation by keeping it in the global model.\n<info added on 2025-11-10T18:42:20.696Z>\nAdded comprehensive severity-based CSS in style.css (100 lines). 5 alert classes (alert-severe/high/moderate/low/clear) with Tailwind colors, severity badges, alert-card styling, and responsive design. Bundle size: 6.45 kB CSS (+1.12 kB).\n</info added on 2025-11-10T18:42:20.696Z>",
            "status": "pending",
            "testStrategy": "E2E tests to verify the stat updates correctly on alert changes and persists across navigation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate WebSocket for Real-Time Alert Reception",
            "description": "Connect the component to WebSocket events to receive and display incoming weather alerts in JSON format.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Extend the WebSocket module integration in WeatherAlertBanner.elm to listen for alert messages, parse the JSON (e.g., {\"type\":\"alert\",\"severity\":\"Severe\",\"message\":\"...\"}), add them to the model, and trigger view updates. Handle message queuing if needed during disconnections.",
            "status": "pending",
            "testStrategy": "E2E tests simulating WebSocket messages to verify alerts appear in the banner and stats update accordingly.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a single Elm component with WebSocket integration."
      },
      {
        "id": 7,
        "title": "Build Backend Weather Monitoring Service",
        "description": "Develop a background service to monitor weather conditions and generate alerts for affected bookings.",
        "details": "In Rust, create WeatherMonitorService as an async task that runs every 5 minutes, fetching weather data from OpenWeatherMap API for upcoming flight locations (next 24h). Analyze for dangerous conditions (wind > threshold, visibility < threshold) and generate WeatherAlert structs. Save alerts to database, broadcast via WebSocket to clients. Include logic to detect affected bookings and handle alert expiration.",
        "testStrategy": "Unit tests for weather analysis logic in Rust (mock API responses). Integration tests for alert generation and broadcasting. E2E tests to verify alerts are triggered based on simulated weather data.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Weather Data Fetching and Analysis Logic",
            "description": "Develop the core logic for fetching weather data from OpenWeatherMap API and analyzing it for dangerous conditions.",
            "dependencies": [],
            "details": "In Rust, implement an async function to fetch weather data for upcoming flight locations within the next 24 hours using the OpenWeatherMap API. Analyze the data for thresholds like wind speed and visibility, determining if conditions are dangerous. This should include error handling for API failures and data parsing.",
            "status": "pending",
            "testStrategy": "Unit tests for weather analysis logic using mock API responses to verify condition detection.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Alert Generation, Broadcasting, and Database Integration",
            "description": "Create logic to generate WeatherAlert structs, save them to the database, and broadcast via WebSocket, including handling affected bookings and alert expiration.",
            "dependencies": [
              1
            ],
            "details": "In Rust, build the WeatherAlert struct generation based on analyzed weather data. Integrate with the database to save alerts and detect affected bookings. Implement WebSocket broadcasting to clients and logic for alert expiration. Ensure atomic operations and proper error handling for database and WebSocket interactions.",
            "status": "pending",
            "testStrategy": "Integration tests for alert generation, database saving, and WebSocket broadcasting, including E2E tests with simulated data.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into subtasks for weather data fetching and analysis logic, and alert generation/broadcasting with database integration."
      },
      {
        "id": 8,
        "title": "Create Reschedule Modal UI with Options Display",
        "description": "Build the UI for the reschedule modal, displaying AI-suggested options with availability and weather indicators.",
        "details": "In Elm, implement RescheduleModal.elm triggered by `[data-testid=\"reschedule-btn\"]`. Display original booking details, 3 options as cards with `[data-testid=\"option-time\"]`, reasoning, availability badge (green/red), weather indicator (green/yellow/red), and select buttons (disabled for unavailable). Use the defined Elm types (RescheduleOption, AvailabilityStatus, WeatherStatus). Handle loading states during API calls.",
        "testStrategy": "Unit tests for modal rendering and option display in Elm. E2E tests to open modal, verify options show correctly, and buttons enable/disable based on availability.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up RescheduleModal.elm structure and trigger",
            "description": "Create the basic Elm module for RescheduleModal with model, view, and update functions, and wire it to be triggered by the reschedule button.",
            "dependencies": [],
            "details": "Initialize RescheduleModal.elm with necessary imports, define the Model type to include modal state, original booking, and options list. Implement the view function to render a basic modal container, and update the main application to open the modal when the [data-testid=\"reschedule-btn\"] is clicked. Ensure the modal can be closed and integrates with existing Elm architecture.\n<info added on 2025-11-10T18:12:43.259Z>\nFully implemented reschedule modal in elm/src/Main.elm:937-1096. Includes loading states, 3 AI options display, availability badges, weather indicators, and confirmation dialog. Uses test IDs matching E2E specs.\n</info added on 2025-11-10T18:12:43.259Z>",
            "status": "pending",
            "testStrategy": "Unit tests for modal initialization and trigger event in Elm.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Display original booking details in modal",
            "description": "Add a section to the modal to show the original booking information.",
            "dependencies": [
              1
            ],
            "details": "In the RescheduleModal view, add a dedicated area to display the original booking details such as date, time, student level, aircraft, and location. Use appropriate Elm types and ensure the data is passed from the parent component or fetched if needed. Style it clearly to distinguish from options.",
            "status": "pending",
            "testStrategy": "Unit tests for rendering original booking data in the modal view.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement option cards with time and reasoning",
            "description": "Create cards for each of the 3 AI-suggested reschedule options, showing time and reasoning.",
            "dependencies": [
              1
            ],
            "details": "In the view, map over the list of RescheduleOption to render 3 cards, each with [data-testid=\"option-time\"] for the suggested time and a section for reasoning. Use the defined Elm types for RescheduleOption. Ensure cards are laid out properly, perhaps in a grid or list, and handle cases where options are not yet loaded.",
            "status": "pending",
            "testStrategy": "Unit tests for option card rendering with mock data.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add availability and weather indicators to options",
            "description": "Enhance option cards with availability badges and weather indicators.",
            "dependencies": [
              3
            ],
            "details": "For each option card, add an availability badge (green for available, red for unavailable) based on AvailabilityStatus, and a weather indicator (green/yellow/red) based on WeatherStatus. Disable select buttons for unavailable options. Use the defined types and ensure visual indicators are clear and accessible.",
            "status": "pending",
            "testStrategy": "Unit tests for indicator logic and button states.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Handle loading states and API interactions",
            "description": "Implement loading indicators and handle API calls for fetching options.",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Add loading spinners or placeholders in the modal during API calls to fetch reschedule options. Update the model to track loading state and disable interactions while loading. Integrate with the backend API (likely via ports or commands) to trigger option fetching when modal opens, and handle errors gracefully by showing appropriate messages.",
            "status": "pending",
            "testStrategy": "Unit tests for loading state management and E2E tests for API integration.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a UI modal component in Elm.",
        "updatedAt": "2025-11-10T18:12:22.349Z"
      },
      {
        "id": 9,
        "title": "Integrate OpenAI API for AI-Powered Suggestions",
        "description": "Connect to OpenAI API to generate intelligent reschedule options based on booking details and constraints.",
        "details": "In Rust, implement a service to call OpenAI API with the specified prompt template, passing current booking data (datetime, student level, aircraft, location), reason, weather forecast, and instructor availability. Parse response to extract 3 reschedule options with reasoning. Cache suggestions to manage costs. Handle API errors gracefully.",
        "testStrategy": "Unit tests for prompt construction and response parsing in Rust (mock OpenAI responses). Integration tests for API calls. E2E tests to verify suggestions are generated and displayed in the modal.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement OpenAI API Service for Prompt Construction and Response Parsing",
            "description": "Develop the core Rust service to construct prompts using booking details and parse OpenAI API responses to extract 3 reschedule options with reasoning.",
            "dependencies": [],
            "details": "In Rust, create a service module that formats the prompt template with inputs such as booking datetime, student level, aircraft, location, reason, weather forecast, and instructor availability. Implement the API call to OpenAI using an HTTP client, then parse the JSON response to extract exactly 3 reschedule options, each including a new datetime and reasoning text. Ensure the service handles the specified prompt template accurately.",
            "status": "pending",
            "testStrategy": "Unit tests for prompt construction logic and response parsing using mocked OpenAI JSON responses to verify extraction of options and reasoning.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Caching and Error Handling for OpenAI API Integration",
            "description": "Implement caching to store and retrieve AI suggestions for cost management, and add graceful error handling for API failures.",
            "dependencies": [],
            "details": "In Rust, integrate a caching layer (e.g., using Redis or an in-memory store) to cache suggestions based on a hash of booking data inputs, with configurable TTL to reduce API calls and manage costs. Implement error handling for API issues like timeouts, rate limits, and invalid responses, including retries with exponential backoff, fallback to default options, and logging. Ensure the system remains functional during outages.",
            "status": "pending",
            "testStrategy": "Unit tests for caching retrieval and storage, and error handling scenarios using mocked API failures. Integration tests to verify caching reduces actual API calls.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide into subtasks for API service implementation (prompt construction, response parsing) and caching/error handling.",
        "updatedAt": "2025-11-10T18:12:27.201Z"
      },
      {
        "id": 10,
        "title": "Implement Backend Reschedule API and Business Logic",
        "description": "Develop the PATCH `/api/bookings/{id}/reschedule` endpoint with validation, updates, and notifications.",
        "details": "In Rust, create the endpoint to handle RescheduleRequest, validate instructor availability and weather suitability, update booking record, log to booking_reschedule_history table (via SQL migration), and send notifications (WebSocket, email). Ensure atomic operations and error handling. Integrate with existing booking logic.",
        "testStrategy": "Unit tests for business logic (availability checks) in Rust. Integration tests for database updates and notifications. E2E tests for full reschedule flow, including API calls and booking updates.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Reschedule Endpoint with Validation and Updates",
            "description": "Create the PATCH /api/bookings/{id}/reschedule endpoint in Rust, handling RescheduleRequest, validating instructor availability and weather suitability, updating the booking record, logging to booking_reschedule_history table via SQL migration, and ensuring atomic operations with error handling. Integrate with existing booking logic.",
            "dependencies": [],
            "details": "In the Rust backend, define the endpoint route using a web framework like Actix or Rocket. Parse the RescheduleRequest payload, perform validations for instructor availability (check schedules) and weather suitability (integrate with weather API or data). Use database transactions to atomically update the booking record and insert into booking_reschedule_history. Handle errors gracefully, returning appropriate HTTP status codes and messages. Ensure integration with existing booking logic for consistency.\n<info added on 2025-11-10T18:12:55.805Z>\nAdditionally, implemented GET /api/bookings/:id/reschedule-suggestions endpoint in server/src/routes/bookings.rs:162-242, which fetches weather forecast, instructor schedule, and calls existing AI client to generate 3 options, returning JSON with availability and weather scores.\n</info added on 2025-11-10T18:12:55.805Z>",
            "status": "pending",
            "testStrategy": "Unit tests for validation logic and database updates in Rust. Integration tests to verify atomic operations and error handling.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Notification Logic for Reschedule",
            "description": "Develop the notification system for reschedule events, including WebSocket real-time updates and email notifications to relevant parties.",
            "dependencies": [
              1
            ],
            "details": "After successful reschedule update, send WebSocket messages to connected clients for real-time updates (e.g., booking changes). Also, trigger email notifications using an email service like SendGrid or SMTP, informing the user, instructor, and possibly admins about the reschedule. Ensure notifications are sent asynchronously to avoid blocking the API response. Integrate with existing notification infrastructure if available.",
            "status": "pending",
            "testStrategy": "Unit tests for notification sending logic in Rust. Integration tests for WebSocket message delivery and email sending. E2E tests to confirm notifications are triggered post-reschedule.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into subtasks for endpoint creation (validation, updates) and notification logic (WebSocket, email).",
        "updatedAt": "2025-11-10T18:12:32.310Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-10T18:12:32.310Z",
      "taskCount": 10,
      "completedCount": 3,
      "tags": [
        "next"
      ],
      "created": "2025-11-10T18:12:39.672Z",
      "description": "Tasks for next context"
    }
  }
}